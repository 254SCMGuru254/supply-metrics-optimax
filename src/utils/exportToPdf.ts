import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';

/**
 * Exports the content of a specified HTML element to a PDF file
 * @param elementId The ID of the HTML element to export
 * @param fileName The name of the PDF file (without extension)
 */
export const exportToPdf = async (
  elementId: string, 
  fileName: string = 'optimization-results'
): Promise<void> => {
  try {
    // Get the HTML element
    const element = document.getElementById(elementId);
    if (!element) {
      throw new Error(`Element with ID ${elementId} not found`);
    }

    // Create canvas from the element
    const canvas = await html2canvas(element, {
      scale: 2, // Higher scale for better quality
      logging: false,
      useCORS: true, // Enable CORS to load external images
      allowTaint: true,
    });

    // Calculate dimensions
    const imgWidth = 210; // A4 width in mm (210mm x 297mm)
    const imgHeight = (canvas.height * imgWidth) / canvas.width;
    
    // Create PDF
    const pdf = new jsPDF('p', 'mm', 'a4');
    const imgData = canvas.toDataURL('image/png');
    
    // Add image to PDF (with 10mm margins)
    pdf.addImage(imgData, 'PNG', 10, 10, imgWidth - 20, imgHeight - 20);
    
    // Save the PDF
    pdf.save(`${fileName}.pdf`);
    
    return Promise.resolve();
  } catch (error) {
    console.error('Error exporting to PDF:', error);
    throw error;
  }
};

/**
 * Exports the optimization results to a PDF file with a formatted report
 * @param networkName The name of the supply chain network
 * @param optimizationType The type of optimization performed
 * @param results The optimization results object
 * @param fileName The name of the PDF file (without extension)
 */
export const exportOptimizationResultsToPdf = (
  networkName: string,
  optimizationType: string,
  results: any,
  fileName: string = 'optimization-results'
): void => {
  // Create a temporary div to render the report
  const reportDiv = document.createElement('div');
  reportDiv.id = 'temp-report-container';
  reportDiv.style.position = 'absolute';
  reportDiv.style.left = '-9999px';
  reportDiv.style.top = '-9999px';
  
  // Format the report content with styling
  reportDiv.innerHTML = `
    <div style="font-family: Arial, sans-serif; padding: 20px; width: 800px;">
      <h1 style="text-align: center; color: #333;">Supply Metrics Optimax</h1>
      <h2 style="text-align: center; color: #666;">Optimization Results Report</h2>
      <hr style="margin: 20px 0;" />
      
      <div style="margin: 20px 0;">
        <h3>Network Information</h3>
        <p><strong>Network Name:</strong> ${networkName}</p>
        <p><strong>Optimization Type:</strong> ${optimizationType}</p>
        <p><strong>Date Generated:</strong> ${new Date().toLocaleString()}</p>
      </div>
      
      <div style="margin: 20px 0;">
        <h3>Optimization Results</h3>
        <div id="results-container">
          ${formatResultsAsHTML(results)}
        </div>
      </div>
      
      <div style="margin: 20px 0; font-size: 12px; color: #999; text-align: center;">
        <p>Generated by Supply Metrics Optimax - Kenya's Supply Chain Optimization Platform</p>
      </div>
    </div>
  `;
  
  // Add to document, export, then remove
  document.body.appendChild(reportDiv);
  
  exportToPdf('temp-report-container', fileName)
    .then(() => {
      document.body.removeChild(reportDiv);
    })
    .catch(error => {
      console.error('Failed to export report:', error);
      document.body.removeChild(reportDiv);
    });
};

/**
 * Formats the optimization results as HTML
 * @param results The optimization results object
 * @returns HTML string representing the results
 */
const formatResultsAsHTML = (results: any): string => {
  if (!results) return '<p>No results available</p>';
  
  let html = '';
  
  // Handle different types of results
  if (results.selected_facilities) {
    html += '<h4>Selected Facilities</h4>';
    html += '<ul>';
    results.selected_facilities.forEach((facility: string) => {
      html += `<li>${facility}</li>`;
    });
    html += '</ul>';
  }
  
  if (results.optimal_routes) {
    html += '<h4>Optimal Routes</h4>';
    html += '<table style="width: 100%; border-collapse: collapse;">';
    html += '<tr><th style="border: 1px solid #ddd; padding: 8px;">From</th><th style="border: 1px solid #ddd; padding: 8px;">To</th><th style="border: 1px solid #ddd; padding: 8px;">Cost</th><th style="border: 1px solid #ddd; padding: 8px;">Volume</th></tr>';
    results.optimal_routes.forEach((route: any) => {
      html += `<tr>
        <td style="border: 1px solid #ddd; padding: 8px;">${route.from}</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${route.to}</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${route.cost || 'N/A'}</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${route.volume || 'N/A'}</td>
      </tr>`;
    });
    html += '</table>';
  }
  
  // Add a section for resilience metrics if available
  if (results.resilience_metrics) {
    html += '<h4>Resilience Metrics</h4>';
    html += '<table style="width: 100%; border-collapse: collapse;">';
    html += '<tr><th style="border: 1px solid #ddd; padding: 8px;">Metric</th><th style="border: 1px solid #ddd; padding: 8px;">Score</th></tr>';
    
    const metrics = results.resilience_metrics;
    if (metrics.connectivity_score) {
      html += `<tr>
        <td style="border: 1px solid #ddd; padding: 8px;">Connectivity</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${metrics.connectivity_score.toFixed(2)}%</td>
      </tr>`;
    }
    if (metrics.redundancy_score) {
      html += `<tr>
        <td style="border: 1px solid #ddd; padding: 8px;">Redundancy</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${metrics.redundancy_score.toFixed(2)}%</td>
      </tr>`;
    }
    if (metrics.adaptability_score) {
      html += `<tr>
        <td style="border: 1px solid #ddd; padding: 8px;">Adaptability</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${metrics.adaptability_score.toFixed(2)}%</td>
      </tr>`;
    }
    
    html += '</table>';
  }
  
  // Add general statistics and cost summaries
  if (results.total_cost || results.total_distance || results.execution_time) {
    html += '<h4>Summary Statistics</h4>';
    html += '<table style="width: 100%; border-collapse: collapse;">';
    
    if (results.total_cost) {
      html += `<tr>
        <td style="border: 1px solid #ddd; padding: 8px;">Total Cost</td>
        <td style="border: 1px solid #ddd; padding: 8px;">KES ${results.total_cost.toLocaleString()}</td>
      </tr>`;
    }
    
    if (results.total_distance) {
      html += `<tr>
        <td style="border: 1px solid #ddd; padding: 8px;">Total Distance</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${results.total_distance.toLocaleString()} km</td>
      </tr>`;
    }
    
    if (results.execution_time) {
      html += `<tr>
        <td style="border: 1px solid #ddd; padding: 8px;">Execution Time</td>
        <td style="border: 1px solid #ddd; padding: 8px;">${results.execution_time.toFixed(2)} seconds</td>
      </tr>`;
    }
    
    html += '</table>';
  }
  
  // If we don't have structured data, just stringify the results
  if (html === '') {
    html = `<pre style="background-color: #f5f5f5; padding: 10px; border-radius: 5px; overflow: auto;">${JSON.stringify(results, null, 2)}</pre>`;
  }
  
  return html;
};
